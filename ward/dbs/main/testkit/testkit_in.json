{
  "uri": "xo.05919057190759",
  "aux": "testkit",
  "kind": "interpreter",
  "name": "'testkit' aux interpreter",
  "media": "\nlain.rom.testkit_handler = {\n    pendingAsyncOps: 0,\n    allAsyncOpsResolvedCallback: null,\n    js: (input) => {\n        if (lain.cache.find(obj => { return Object.keys(input).every(key => obj.hasOwnProperty(key) && obj[key] === input[key]); }) === undefined) {\n            try { eval(input.media); input.step = lain.proc.length; lain.cache.push(input); }\n            catch (error) { console.log('failed to evaluate function(s)', input.name, 'due to error:', error) }\n        } else { console.log('function(s) already cached') }\n    },\n    jsmod: (input) => {\n        if (lain.cache.find(obj => Object.keys(input).every(key => obj.hasOwnProperty(key) && obj[key] === input[key])) === undefined) {\n            try {\n                const fetchmod = async (modURL) => {\n                    const headers = new Headers();\n                    const httxid = input.httxid || lain.subs[modURL];\n                    if (httxid) {\n                        headers.append('httx', httxid);\n                    }\n                    try {\n                        const response = await fetch(lain.portal + modURL, { headers });\n                        if (!response.ok) {\n                            throw new Error('HTTP error! status: ' + response.status);\n                        }\n                        const blob = await response.blob();\n                        const objectURL = URL.createObjectURL(blob);\n                        try {\n                            const mod = await import(objectURL);\n                            URL.revokeObjectURL(objectURL);\n                            if (mod && mod.activate_module) {\n                                mod.activate_module(lain);\n                                console.log('mod imported with activation:', input.name);\n                            } else {\n                                console.log('mod imported without activation:', input.name);\n                            }\n                        } catch (importErr) {\n                            console.error('Error during mod import:', importErr);\n                        }\n                    } catch (error) {\n                        console.error('Error importing mod:', error);\n                    } finally {\n                        lain.rom.testkit_handler.pendingAsyncOps--;\n                        if (lain.rom.testkit_handler.pendingAsyncOps === 0 && lain.rom.testkit_handler.allAsyncOpsResolvedCallback) {\n                            lain.rom.testkit_handler.allAsyncOpsResolvedCallback();\n                        }\n                    }\n                };\n                const modURL = input.media;\n                console.log('importing async:', input.name);\n                lain.rom.testkit_handler.pendingAsyncOps++;\n                fetchmod(modURL);\n                input.step = lain.proc.length;\n                lain.cache.push(input);\n            } catch (error) {\n                console.log('failed to evaluate function(s)', input.name, 'due to error:', error);\n            }\n        } else {\n            console.log('function(s) already cached');\n        }\n    },\n    html: (input, target) => {\n        if (input.hasOwnProperty('count')) {\n            const matches = lain.cache.filter(obj => {\n                return Object.keys(input).every(key => obj.hasOwnProperty(key) && obj[key] === input[key]);\n            });\n            if (matches.length >= input.count) {\n                console.log('item has met cache limit:', matches.length);\n                return;\n            }\n        }\n        var container = document.createElement('div');\n        container.innerHTML = input.media;\n        input.step = lain.proc.length;\n        Array.from(container.childNodes).forEach(node => {\n            if (node.nodeType === 1) {\n                input.domset = lain.domset++;\n                node.setAttribute('data-set', input.domset);\n                node.setAttribute('data-step', input.step);\n                const assignDataSetsToChildren = (childNode) => {\n                    if (childNode.nodeType === 1) {\n                        childNode.setAttribute('data-set', lain.domset++);\n                        Array.from(childNode.children).forEach(assignDataSetsToChildren);\n                    }\n                };\n                Array.from(node.children).forEach(assignDataSetsToChildren);\n            }\n        });\n        while (container.firstChild) {\n            target.insertBefore(container.firstChild, target.firstChild);\n        }\n        const stamp = JSON.parse(JSON.stringify(input));\n        lain.cache.push(stamp);\n        let kidfunc = lain.dvr[input.child];\n        if (kidfunc !== undefined) {\n            if (kidfunc) { eiri(lain, kidfunc); }\n            else { console.log('child func of', input.name, 'not found'); }\n        }\n    }\n};\nwindow.MySecureElement = class extends HTMLElement {\n    constructor() {\n        super();\n        const shadowRoot = this.attachShadow({ mode: 'closed' });\n        const wrapper = document.createElement('div');\n        shadowRoot.appendChild(wrapper);\n        this.wrapper = wrapper;\n    }\n    secure(child) {\n        this.wrapper.appendChild(child);\n    }\n};\nif (!customElements.get('testkit-shadow')) {\n    customElements.define('testkit-shadow', MySecureElement);\n}\nconsole.log('testkit-shadow element:', MySecureElement);\nconsole.log('interpreter registered with callback:', lain.portal);\n"
}